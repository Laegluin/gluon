let process @ { cmd, pipe, StdStreamReader } = import! std.process.prim
let { CommandOption, Stdio, Child } = import! std.process.prim.types
let string = import! std.string
let { map } = import! std.functor
let { Result } = import! std.result
let { flat_map, (>>=) } = import! std.monad
let { wrap } = import! std.applicative
let { sequence } = import! std.traversable
let { index, ? } = import! std.array
let io @ { ? } = import! std.io


let read_to_string reader : StdStreamReader -> IO (Option String) =
    do buf = process.read_to_end reader

    match string.from_utf8 buf with
    | Ok str -> wrap (Some str)
    | Err _ -> wrap None

type ExitCode = Option Int

let exit_code_to_io : ExitCode -> IO () = process.exit_code_to_io

let kill child : Child -> IO () =
    process.kill child.handle

let join child : Child -> IO ExitCode =
    process.join child.stdin child.handle

let join_all processes : Array Child -> IO (Array ExitCode) =
    sequence io.applicative (map join processes)

let spawn program args opts : String -> Array String -> Array CommandOption -> IO Child =
    do child = pipe [cmd program args opts]
    wrap (index child 0)

let run program args : String -> Array String -> IO () =
    spawn program args [] >>= join >>= exit_code_to_io

let is_success exit_code : ExitCode -> Bool =
    match exit_code with
    | Some code -> code == 0
    | None -> False


{ 
    ExitCode,
    CommandOption,
    Stdio,
    Child,
    join,
    join_all,
    exit_code_to_io,
    spawn,
    run,
    kill,
    is_success,
    read_to_string,
    ..process 
}
